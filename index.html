<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="assets/css/style.min.css">
  <link rel="stylesheet" href="assets/css/reset.css">
  <title>Quotes Random</title>
</head>

<body>
  <header>
    <nav aria-label="List of categories">
      <form action="#" method="POST">
        <fieldset>
          <div>
            <label for="category"></label>
            <select name="category" id="category" class="select">
              <option value="">Choose a category</option>
            </select>
          </div>
          <button data-text="More Quotes" type="submit" aria-label="Show another quote" id="submit"
            class="tooltip right">"</button>
        </fieldset>
      </form>
    </nav>
  </header>
  <main>
    <figure class="quote">
      <blockquote>
        But web browsers aren’t like web servers. If your back-end code is getting so big that it’s starting to run
        noticably slowly, you can throw more computing power at it by scaling up your server. That’s not an option on
        the front-end where you don’t really have one run-time environment—your end users have their own run-time
        environment with its own constraints around computing power and network connectivity.
      </blockquote>
      <figcaption>
        &mdash; Jeremy Keith, <cite>Mental models</cite>
      </figcaption>
    </figure>
  </main>
  <script type="module" async defer src="assets/js/main.js"></script>
</body>

</html>